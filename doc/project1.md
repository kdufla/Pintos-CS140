პროექტი #1 - ნაკადები: დიზაინ დოკუმენტი
========================================

#### თბილისის თავისუფალი უნივერსიტეტი,  MACS, ოპერაციული სისტემების ინჟინერია, გაზაფხული-2018.

### ჯგუფის წევრები

* გიორგი გველესიანი <ggvel14@freeuni.edu.ge>
* ალექსანდრე აბრამიშვილი <aabra12@freeuni.edu.ge>
* ალექსანდრე კახიძე <alkakh14@freeuni.edu.ge>
* ალექსანდრე ნაკაიძე <anaka13@freeuni.edu.ge>


# 1. Efficient Alarm Clock
*ეფექტური მაღვიძარა*

## მონაცემთა სტრუქტურები და ფუნქციები

### ცვლადები

* `static struct list sleep_list` - დაძინებული ნაკადების სია.
* `int64_t wake_time` `struct thread`-ში - დრო, როცა უნდა გაიღვიძოს ამ ნაკადმა, ითვლება `timer_ticks` ერთეულში, ნულობან მომენტად კი აღებულია სისტემის ჩართვა.

### ფუნქციები

* `void thread_sleep (int64_t untill)` - აძინებს მიმდინარე ნაკადს და `wake_time`-ად უწერს `untill`-ს.
* `void thread_wake(void)` - აღვიძებს ყველა გასაღვიძებელ ნაკადს, ანუ რომელთა `wake_time`-იც მოვიდა.

## ალგორითმები

იმის მაგივრად, რომ `timer_sleep` ფუნქცია, რომელიც გამოიძახება ნაკადის მოთხოვნით, *busy waiting*-ით ელოდებოდეს სანამ გაღვიძების დრო მოვა, ითვლის გასაღვიძებელ დროს და იძახებს `thread_sleep` ფუნქციას მიმდინარე ნაკადისთვის, რომელიც თავისმხრივ ათავსებს ამ ნაკადს `sleep_list`-ში და ბლოკავს ნაკადს, ანუ ეს ნაკადი არ ხვდება `ready_list`-ში.

პერიოდულად, ყოველი `timer_interrupt`-ისას, გამოიძახება `thread_wake` ფუნქცია, რომელიც ამოწმებს დაძინებულ ნაკადებს შორის, რომელიმეს გაღვიძების დრო თუ არის მოსული, და თუ ასეა, გადააქვს ეს ნაკადი `ready_list`-ში.

`sleep_list`-ში ნაკადების ჩადება ხდება გასაღვიძებელი დროის მიხედვით, ისე, რომ სიის დასაწყისში იდოს ყველაზე მალე გასაღვიძებელი ნაკადი.

## სინქრონიზაცია

იმის გამო, რომ `thread_sleep` და `thread_wake` ფუნქციები ცვლიან ნაკადების სიებს, აუცილებელია, რომ არ მოხდეს ამ ფუნქციების შუაზე შეწყვეტა, შესაბამისად ამ ორივე ფუნქციის შესრულებისას საჭირო არის *interrupt*-ების გამორთვა. იმის გამო, რომ `thread_wake` გამოიძახება ყოველი *tick*-ისას და მხოლოდ იშვიათად არის საჭირო სიებში ცვლილებების შეტანა, არაოპტიმალური იქნებოდა ყოველ ჯერზე *interrupt*-ების გამორთვა, ამიტომაც მხოლოდ მაშინ ირთვება, როცა მოიძებნება გასაღვიძებელი ნაკადი.

## რატომ ავირჩიეთ ეს მიდგომა

პირველ რიგში, ზემოთ აღწერილი მექანიზმი უმარტივესი ვარიანტია კოდის დაწერის რაოდენობის მხრივადაც და რაც მთავარია ოპტიმალურია იმის ხარჯზე, რომ `sleep_list`-ში ნაკადებს ალაგებს გაღვიძების დროის მიხედვით, რაც იმის საშუალებას იძლევა, რომ ყოველი *tick*-ისას, საშუალოდ მხოლოდ ერთი, პირველივე ნაკადის გაღვიძების დრო შემოწმდეს; იშვიათ შემთხვევაში, როდესაც მართლაც გასაღვიძებელი დროა, ორი ნაკადის გაღვიძების დროა შესამოწმებელი და უარეს შემთხვევაში, როდესაც ისე აღმოჩნდება, რომ ყველა დაძინებული ნაკადის გაღვიძების დრო მაინც და მაინც ერთი *tick*-ის ფარგლებში დაემთხვა, მაშინ მთელი სიის შემოწმებაა საჭირო. თუმცა ეს უკანასკნელი იმდენად მარგინალური შემთხვევაა, რომ ეს ალგორითმი საშუალოდ O(1) დროში მუშაობს.

# 2. Priority Scheduler
*პრიორიტეტების მიხედვით დამგეგმავი*

## მონაცემთა სტრუქტურები და ფუნქციები

## ალგორითმები

## სინქრონიზაცია

## იმპლემენტაციის სისწორის დასაბუთება

# 3. Multi-level Feedback Queue Scheduler
*მრავალდონიანი უკუკავშირის მქონე რიგის დამგეგმავი*

## მონაცემთა სტრუქტურები და ფუნქციები

## ალგორითმები

## სინქრონიზაცია

## იმპლემენტაციის სისწორის დასაბუთება

# დამატებითი კითხვები

## 1

## 2

timer ticks | R(A) | R(B) | R(C) | P(A) | P(B) | P(C) | thread to run
------------|------|------|------|------|------|------|--------------
 0          |      |      |      |      |      |      |
 4          |      |      |      |      |      |      |
 8          |      |      |      |      |      |      |
12          |      |      |      |      |      |      |
16          |      |      |      |      |      |      |
20          |      |      |      |      |      |      |
24          |      |      |      |      |      |      |
28          |      |      |      |      |      |      |
32          |      |      |      |      |      |      |
36          |      |      |      |      |      |      |

## 3