პროექტი #1 - ნაკადები: დიზაინ დოკუმენტი
========================================

#### თბილისის თავისუფალი უნივერსიტეტი,  MACS, ოპერაციული სისტემების ინჟინერია, გაზაფხული-2018.

### ჯგუფის წევრები

* გიორგი გველესიანი <ggvel14@freeuni.edu.ge>
* ალექსანდრე აბრამიშვილი <aabra12@freeuni.edu.ge>
* ალექსანდრე კახიძე <alkakh14@freeuni.edu.ge>
* ალექსანდრე ნაკაიძე <anaka13@freeuni.edu.ge>


# 1. Efficient Alarm Clock
*ეფექტური მაღვიძარა*

## მონაცემთა სტრუქტურები და ფუნქციები

### ცვლადები

* `static struct list sleep_list` - დაძინებული ნაკადების სია.
* `int64_t wake_time` `struct thread`-ში - დრო, როცა უნდა გაიღვიძოს ამ ნაკადმა, ითვლება `timer_ticks` ერთეულში, ნულობან მომენტად კი აღებულია სისტემის ჩართვა.

### ფუნქციები

* `static bool cmp_wake (const struct list_elem *a, const struct list_elem *b, void *aux)` - ადარებს ორი ნაკადის გასაღვიძებელ დროებს.
* `void thread_sleep (int64_t untill)` - აძინებს მიმდინარე ნაკადს და `wake_time`-ად უწერს `untill`-ს.
* `void thread_wake(void)` - აღვიძებს ყველა გასაღვიძებელ ნაკადს, ანუ რომელთა `wake_time`-იც მოვიდა.

## ალგორითმები

იმის მაგივრად, რომ `timer_sleep` ფუნქცია, რომელიც გამოიძახება ნაკადის მოთხოვნით, *busy waiting*-ით ელოდებოდეს სანამ გაღვიძების დრო მოვა, ითვლის გასაღვიძებელ დროს და იძახებს `thread_sleep` ფუნქციას მიმდინარე ნაკადისთვის, რომელიც თავისმხრივ ათავსებს ამ ნაკადს `sleep_list`-ში და ბლოკავს ნაკადს, ანუ ეს ნაკადი არ ხვდება `ready_list`-ში.

პერიოდულად, ყოველი `timer_interrupt`-ისას, გამოიძახება `thread_wake` ფუნქცია, რომელიც ამოწმებს დაძინებულ ნაკადებს შორის, რომელიმეს გაღვიძების დრო თუ არის მოსული, და თუ ასეა, გადააქვს ეს ნაკადი `ready_list`-ში.

`sleep_list`-ში ნაკადების ჩადება ხდება გასაღვიძებელი დროის მიხედვით, ისე, რომ სიის დასაწყისში იდოს ყველაზე მალე გასაღვიძებელი ნაკადი.

## სინქრონიზაცია

იმის გამო, რომ `thread_sleep` და `thread_wake` ფუნქციები ცვლიან ნაკადების სიებს, აუცილებელია, რომ არ მოხდეს ამ ფუნქციების შუაზე შეწყვეტა, შესაბამისად ამ ორივე ფუნქციის შესრულებისას საჭირო არის *interrupt*-ების გამორთვა. იმის გამო, რომ `thread_wake` გამოიძახება ყოველი *tick*-ისას და მხოლოდ იშვიათად არის საჭირო სიებში ცვლილებების შეტანა, არაოპტიმალური იქნებოდა ყოველ ჯერზე *interrupt*-ების გამორთვა, ამიტომაც მხოლოდ მაშინ ირთვება, როცა მოიძებნება გასაღვიძებელი ნაკადი.

## რატომ ავირჩიეთ ეს მიდგომა

პირველ რიგში, ზემოთ აღწერილი მექანიზმი უმარტივესი ვარიანტია კოდის დაწერის რაოდენობის მხრივადაც და რაც მთავარია ოპტიმალურია იმის ხარჯზე, რომ `sleep_list`-ში ნაკადებს ალაგებს გაღვიძების დროის მიხედვით, რაც იმის საშუალებას იძლევა, რომ ყოველი *tick*-ისას, საშუალოდ მხოლოდ ერთი, პირველივე ნაკადის გაღვიძების დრო შემოწმდეს; იშვიათ შემთხვევაში, როდესაც მართლაც გასაღვიძებელი დროა, ორი ნაკადის გაღვიძების დროა შესამოწმებელი და უარეს შემთხვევაში, როდესაც ისე აღმოჩნდება, რომ ყველა დაძინებული ნაკადის გაღვიძების დრო მაინც და მაინც ერთი *tick*-ის ფარგლებში დაემთხვა, მაშინ მთელი სიის შემოწმებაა საჭირო. თუმცა ეს უკანასკნელი იმდენად მარგინალური შემთხვევაა, რომ ეს ალგორითმი საშუალოდ O(1) დროში მუშაობს.

# 2. Priority Scheduler
*პრიორიტეტების მიხედვით დამგეგმავი*

## მონაცემთა სტრუქტურები და ფუნქციები

### ცვლადები

დამატებითი ცვლადები `struct thread`-ში:

* `int actual_priority` - ნაკადის პრიორიტეტი, რომელსაც დონაცია ვერ ცვლის.
* `struct lock *waiting_for` - *lock*-ი, რომლის აღებასაც ცდილობს ნაკადი.
* `struct list locks` - აღებული *lock*-ების სია.

### ფუნქციები

* `bool sema_comp (const struct list_elem *a, const struct list_elem *b, void *aux)` - ადარებს სემაფორებს მათი მფლობელი ნაკადების პრიორიტეტების მიხედვით.
* `void donate_my_priority(struct thread *holder, int priority)` - პრიორიტეტების დონაცია. ანიჭებს ნაკად `holder`-ს მოცემულ პრიორიტეტს (`priority`-ს და არა `actual_priority`-ს), თუ `holder`-ი ასევე ელოდება სხვა *lock*-ს, რეკურსიულად აგრძელებს დონაციას, სანამ გაუჭედავ ნაკადამდე არ მივა გადმოცემული პრიორიტეტი.
* `bool priority_list_less_func (const struct list_elem *a, const struct list_elem *b, void *aux)` - ადარებს ნაკადებს მათი პრიორიტეტის მიხედვით.
* `void add_thread_to_ready_queue(struct thread *t)` - ამატებს ნაკადს `ready_list`-ში პრიორიტეტების მიხედვით დალაგებულად.
* `void readd_thread_to_ready_queue(struct thread *t)` - გადაადგილებს ნაკადს `ready_list`, თუკი საჭიროა.

## ალგორითმები

### გაშვებადი ნაკადების სია

გაშვებადი ნაკადების სია ანუ `ready_list`-ი შედგება მხოლოდ ერთი სიისგან, რომელშიც ნაკადები დალაგებულია მათი პრიორიტეტების ზრდის მიხედვით. დამგეგმავი, ანუ *scheduler*-ი გასაშვებ ნაკადს იღებს ყოველთვის ამ სიის ბოლოდან, რადგან ბოლოში ყველაზე მაღალპრიორიტეტიანი ხვდება. ხოლო ჩამატება ხდება `priority_list_less_func`-ის გამოყენებით, რისი მეშვეობითაც ნაკადი ვარდება თავისი ტოლი პრიორიტეტებიანი ნაკადების თავში. შესაბამისად ერთნაირი პრიორიტეტების მქონე ნაკადებისთვის ეს სია მოქმედებს, როგორც *round robin*-ი.

### დონაცია

იმის გამო, რომ ნაკადს აქვს დამატებითი ცვლადი `actual_priority`, აღარაა საჭირო ზედმეტი გამოთვლების ჩატარება. როდესაც რომელიმე ნაკადი გაიჭედება, იმის გამო, რომ აღებულ სინქრონიზაციის მექანიზმს (*lock*-ს, სემაფორას) ჰყავს ნაკლებპრიორიტეტიანი მფლობელი, აძლევს საკუთარ პრიორიტეტს `donate_my_priority`-ს მეშვეობით, ანუ უცვლის ნაკადის `priority` ცვლადს, ხოლო `actual_priority`, იმ ნაკადს ისევ ის რჩება რაც თავიდან ჰქონდა, რათა დონაციების საჭიროების მორჩენის შემთხვევაში დაიბრუნოს ის.

ყოველ ჯერზე, როდესაც ნაკადი აკეთებს `lock_release`-ს, თუ მას დონაციით აქვს მიღებული პრიორიტეტი, მან უნდა დაიბრუნოს საკუთარი საწყისი პრიორიტეტი და ისე განაგრძოს მუშაობა. თუმცა, როდესაც მას კიდევ სხვა *lock*-ები აქვს აღებული, საწყისი პრიორიტეტის დაბრუნება ჯერ ადრეა და იგი მისი *lock*-ების მომლოდინეებისგან უმაღლეს პრიორიტეტს იღებს, თუკი მის `actual_priority`-ზე მეტი ჰქონდა რომელიმეს. ეს იმიტომ ხდება, რომ თუკი ვინმე უფრო მაღალპრიორიტეტიანი ელოდება ამ ნაკადის *lock*-ს, მაშინ დონაცია უნდა მოხდეს მასზე ამ მაღალი პრიორიტეტის. ეს პროცესი ხდება არამარტო, `lock_release`-ისა, არამედ `thread_set_priority`-ს დროსაც.

## სინქრონიზაცია

## იმპლემენტაციის სისწორის დასაბუთება

# 3. Multi-level Feedback Queue Scheduler
*მრავალდონიანი უკუკავშირის მქონე რიგის დამგეგმავი*

## მონაცემთა სტრუქტურები და ფუნქციები

## ალგორითმები

## სინქრონიზაცია

## იმპლემენტაციის სისწორის დასაბუთება

# დამატებითი კითხვები

## 1

## 2

timer ticks | R(A) | R(B) | R(C) | P(A) | P(B) | P(C) | thread to run
------------|------|------|------|------|------|------|--------------
 0          |      |      |      |      |      |      |
 4          |      |      |      |      |      |      |
 8          |      |      |      |      |      |      |
12          |      |      |      |      |      |      |
16          |      |      |      |      |      |      |
20          |      |      |      |      |      |      |
24          |      |      |      |      |      |      |
28          |      |      |      |      |      |      |
32          |      |      |      |      |      |      |
36          |      |      |      |      |      |      |

## 3