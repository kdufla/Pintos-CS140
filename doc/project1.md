პროექტი #1 - ნაკადები: დიზაინ დოკუმენტი
========================================

#### თბილისის თავისუფალი უნივერსიტეტი,  MACS, ოპერაციული სისტემების ინჟინერია, გაზაფხული-2018.

### ჯგუფის წევრები

* <a href="ggvel14@freeuni.edu.ge">გიორგი გველესიანი</a>
* <a href="aabra12@freeuni.edu.ge">ალექსანდრე აბრამიშვილი</a>
* <a href="alkakh14@freeuni.edu.ge">ალექსანდრე კახიძე</a>
* <a href="anaka13@freeuni.edu.ge">ალექსანდრე ნაკაიძე</a>

# 1. Efficient Alarm Clock
*ეფექტური მაღვიძარა*

## მონაცემთა სტრუქტურები და ფუნქციები

### ცვლადები

* `static struct list sleep_list` - დაძინებული ნაკადების სია.
* `int64_t wake_time` `struct thread`-ში - დრო, როცა უნდა გაიღვიძოს ამ ნაკადმა, ითვლება `timer_ticks` ერთეულში, ნულობან მომენტად კი აღებულია სისტემის ჩართვა.

### ფუნქციები

* `static bool cmp_wake (const struct list_elem *a, const struct list_elem *b, void *aux)` - ადარებს ორი ნაკადის გასაღვიძებელ დროებს.
* `void thread_sleep (int64_t untill)` - აძინებს მიმდინარე ნაკადს და `wake_time`-ად უწერს `untill`-ს.
* `void thread_wake(void)` - აღვიძებს ყველა გასაღვიძებელ ნაკადს, ანუ რომელთა `wake_time`-იც მოვიდა.

## ალგორითმები

იმის მაგივრად, რომ `timer_sleep` ფუნქცია, რომელიც გამოიძახება ნაკადის მოთხოვნით, *busy waiting*-ით ელოდებოდეს სანამ გაღვიძების დრო მოვა, ითვლის გასაღვიძებელ დროს და იძახებს `thread_sleep` ფუნქციას მიმდინარე ნაკადისთვის, რომელიც თავისმხრივ ათავსებს ამ ნაკადს `sleep_list`-ში და ბლოკავს ნაკადს, ანუ ეს ნაკადი არ ხვდება `ready_list`-ში.

პერიოდულად, ყოველი `timer_interrupt`-ისას, გამოიძახება `thread_wake` ფუნქცია, რომელიც ამოწმებს დაძინებულ ნაკადებს შორის, რომელიმეს გაღვიძების დრო თუ არის მოსული, და თუ ასეა, გადააქვს ეს ნაკადი `ready_list`-ში.

`sleep_list`-ში ნაკადების ჩადება ხდება გასაღვიძებელი დროის მიხედვით, ისე, რომ სიის დასაწყისში იდოს ყველაზე მალე გასაღვიძებელი ნაკადი.

## სინქრონიზაცია

იმის გამო, რომ `thread_sleep` და `thread_wake` ფუნქციები ცვლიან ნაკადების სიებს, აუცილებელია, რომ არ მოხდეს ამ ფუნქციების შუაზე შეწყვეტა, შესაბამისად ამ ორივე ფუნქციის შესრულებისას საჭირო არის *interrupt*-ების გამორთვა. იმის გამო, რომ `thread_wake` გამოიძახება ყოველი *tick*-ისას და მხოლოდ იშვიათად არის საჭირო სიებში ცვლილებების შეტანა, არაოპტიმალური იქნებოდა ყოველ ჯერზე *interrupt*-ების გამორთვა, ამიტომაც მხოლოდ მაშინ ირთვება, როცა მოიძებნება გასაღვიძებელი ნაკადი.

## რატომ ავირჩიეთ ეს მიდგომა

პირველ რიგში, ზემოთ აღწერილი მექანიზმი უმარტივესი ვარიანტია კოდის დაწერის რაოდენობის მხრივადაც და რაც მთავარია ოპტიმალურია იმის ხარჯზე, რომ `sleep_list`-ში ნაკადებს ალაგებს გაღვიძების დროის მიხედვით, რაც იმის საშუალებას იძლევა, რომ ყოველი *tick*-ისას, საშუალოდ მხოლოდ ერთი, პირველივე ნაკადის გაღვიძების დრო შემოწმდეს; იშვიათ შემთხვევაში, როდესაც მართლაც გასაღვიძებელი დროა, ორი ნაკადის გაღვიძების დროა შესამოწმებელი და უარეს შემთხვევაში, როდესაც ისე აღმოჩნდება, რომ ყველა დაძინებული ნაკადის გაღვიძების დრო მაინც და მაინც ერთი *tick*-ის ფარგლებში დაემთხვა, მაშინ მთელი სიის შემოწმებაა საჭირო. თუმცა ეს უკანასკნელი იმდენად მარგინალური შემთხვევაა, რომ ეს ალგორითმი საშუალოდ O(1) დროში მუშაობს.

# 2. Priority Scheduler
*პრიორიტეტების მიხედვით დამგეგმავი*

## მონაცემთა სტრუქტურები და ფუნქციები
შეცვლილი სტრუქტურა `semaphore_elem`:
 ამ სტრუქტურას ჩაემატა ცვლადი struct thread* th
 რომელიც აღნიშნავს სემაფორაზე მომლოდინე ნაკადს.

### ცვლადები

დამატებითი ცვლადები `struct thread`-ში:

* `int actual_priority` - ნაკადის პრიორიტეტი, რომელსაც დონაცია ვერ ცვლის.
* `struct lock *waiting_for` - *lock*-ი, რომლის აღებასაც ცდილობს ნაკადი.
* `struct list locks` - აღებული *lock*-ების სია.

### ფუნქციები

* `bool sema_comp (const struct list_elem *a, const struct list_elem *b, void *aux)` - ადარებს სემაფორებს მათი მომლოდინე ნაკადების პრიორიტეტების მიხედვით.
* `void donate_my_priority(struct thread *holder, int priority)` - პრიორიტეტების დონაცია. ანიჭებს ნაკად `holder`-ს მოცემულ პრიორიტეტს (`priority`-ს და არა `actual_priority`-ს), თუ `holder`-ი ასევე ელოდება სხვა *lock*-ს, რეკურსიულად აგრძელებს დონაციას, სანამ გაუჭედავ ნაკადამდე არ მივა გადმოცემული პრიორიტეტი.
* `bool priority_list_less_func (const struct list_elem *a, const struct list_elem *b, void *aux)` - ადარებს ნაკადებს მათი პრიორიტეტის მიხედვით.
* `void add_thread_to_ready_queue(struct thread *t)` - ამატებს ნაკადს `ready_list`-ში პრიორიტეტების მიხედვით დალაგებულად.
* `void readd_thread_to_ready_queue(struct thread *t)` - გადაადგილებს ნაკადს `ready_list`, თუკი საჭიროა.

## ალგორითმები

### გაშვებადი ნაკადების სია

გაშვებადი ნაკადების სია ანუ `ready_list`-ი შედგება მხოლოდ ერთი სიისგან, რომელშიც ნაკადები დალაგებულია მათი პრიორიტეტების ზრდის მიხედვით. დამგეგმავი, ანუ *scheduler*-ი გასაშვებ ნაკადს იღებს ყოველთვის ამ სიის ბოლოდან, რადგან ბოლოში ყველაზე მაღალპრიორიტეტიანი ხვდება. ხოლო ჩამატება ხდება `priority_list_less_func`-ის გამოყენებით, რისი მეშვეობითაც ნაკადი ვარდება თავისი ტოლი პრიორიტეტებიანი ნაკადების თავში. შესაბამისად ერთნაირი პრიორიტეტების მქონე ნაკადებისთვის ეს სია მოქმედებს, როგორც *round robin*-ი.

### დონაცია

იმის გამო, რომ ნაკადს აქვს დამატებითი ცვლადი `actual_priority`, აღარაა საჭირო ზედმეტი გამოთვლების ჩატარება. როდესაც რომელიმე ნაკადი გაიჭედება, იმის გამო, რომ აღებულ სინქრონიზაციის მექანიზმს (*lock*-ს, სემაფორას) ჰყავს ნაკლებპრიორიტეტიანი მფლობელი, აძლევს საკუთარ პრიორიტეტს `donate_my_priority`-ს მეშვეობით, ანუ უცვლის ნაკადის `priority` ცვლადს, ხოლო `actual_priority`, იმ ნაკადს ისევ ის რჩება რაც თავიდან ჰქონდა, რათა დონაციების საჭიროების მორჩენის შემთხვევაში დაიბრუნოს ის.

ყოველ ჯერზე, როდესაც ნაკადი აკეთებს `lock_release`-ს, თუ მას დონაციით აქვს მიღებული პრიორიტეტი, მან უნდა დაიბრუნოს საკუთარი საწყისი პრიორიტეტი და ისე განაგრძოს მუშაობა. თუმცა, როდესაც მას კიდევ სხვა *lock*-ები აქვს აღებული, საწყისი პრიორიტეტის დაბრუნება ჯერ ადრეა და იგი მისი *lock*-ების მომლოდინეებისგან უმაღლეს პრიორიტეტს იღებს, თუკი მის `actual_priority`-ზე მეტი ჰქონდა რომელიმეს. ეს იმიტომ ხდება, რომ თუკი ვინმე უფრო მაღალპრიორიტეტიანი ელოდება ამ ნაკადის *lock*-ს, მაშინ დონაცია უნდა მოხდეს მასზე ამ მაღალი პრიორიტეტის. ეს პროცესი ხდება არამარტო, `lock_release`-ისა, არამედ `thread_set_priority`-ს დროსაც.

### *condition variables*
ამ სინქრონიზაციის მექანიზმის შემთხვევაში ყოველ სრედზე რომელიც ელოდება ამ *condition variable*-ს ხდება `semaphore_elem`-ის შექმნა რომელიც თავის თავში ინახავს `semaphore`, `list_elem` და `thread* th` ყოველი `condition_wait`-ს დროს ხდება ერთი `semaphore_elem`-ს ინიციალიზაცია და იგი ემატება ქონდიშენზე მომლოდინე ელემენტების სიაში. `condition_signal` ხდება პრიორიტეტების მიხედვით. ამისთვის მისაღწევად ყოველი სიგნალის წინ ხდება მომლოდინე `semaphore_elem`-ს დალაგება მათ სტრუქტურაში არსებული ნაკადების პრიორიტეტების მიხედვით. ამისთვის ვიყენებთ `sema_cmp` ფუნქციას რომელიც ორი `semaphore_elem`-ის შესადარებლად იღებს მათ შესაბამის ცვლად th-ს და ამ ორი ცვლადის `priority`-ებს ადარებს. 


### კიდევ სხვა რამე?

## სინქრონიზაცია

`lock_acquire`-ში შეიძლება მოხდეს race condition, რადგან ამ დროს ხდება დონაცია, რაც ნიშნავს სხვა thread-ის სტრუქტურაში `priority`-ს შეცვლას. რამდენიმე thread-მა ერთად რომ ვერ შეძლოს ამის გაკეთება ამისთვის დროებით უნდა შეჩერდეს scheduling და მიმდინარე thread-ს მიეცეს დონაციის დამთავრების საშუალება. მეორე race condition შეიძლება მოხდეს `sem-up`-ში, როცა ერთსა და იმავე სემაფორაზე შეეცდებიან წვდომას და ამასაც იგივე მიდგომით ვაგვარებთ. ზუსტად იგივეა `lock_release`-ში – დონაციის დაბურუნება და ძველი დონაციის ან საკუთარი პრიორიტეტის აღდგენა ისეთ მონაცემებს ეხება, რასთან არასინქრონიზებულად შეხებამაც მარტივად შეიძლება გამოიწვიოს race condition.

## რატომ ავირჩიეთ ეს მიდგომა

# 3. Multi-level Feedback Queue Scheduler
*მრავალდონიანი უკუკავშირის მქონე რიგის დამგეგმავი*

## მონაცემთა სტრუქტურები და ფუნქციები

### ცვლადები

* `fixed_point_t load_avg` - *System load average*, ანუ უკანასკნელი წუთის განმავლობაში გაშვებადი ნაკადების საშუალო მიახლოება.

დამატებითი ცვლადები `struct thread`-ში:

* `int nice` - *Nice value*, ანუ რამდენად "თავმდაბალია" ნაკადი.
* `fixed_point_t recent_cpu` - უკანასკნელ დროს ნაკადის მიერ გამოყენებული *cpu*-ს რაოდენობის მიახლოება.

### ფუნქციები

* `void recalculate_load_avg (bool is_idle)` - ითვლის *load average*-ს და წერს `load_avg` ცვლადში.
* `void recalculate_recent_cpu (struct thread *th, void *aux)` - ითვლის *recent cpu*-ს მოცემული ნაკადი `th`-სთვის და წერს ამ ნაკადის `recent_cpu` ცვლადში.
* `void recalculate_priority (struct thread *th, void *aux)` - ითვლის მოცემული ნაკადი `th`-სთვის პრიორიტეტს და ამატებს `ready_list`-ში საჭიროებისამებრ.
* `int thread_calculate_priority (struct thread *th)` - ითვლის ნაკადის პრიორიტეტს მის *recent cpu*-ზე და *nice*-ზე დაყრნობით.
* `int priority_in_range (int priority)` - აქცევს მოცემულ პრიორიტეტს `PRI_MIN` და `PRI_MAX` ფარგლებში.

## ალგორითმები

ამ ნაწილის იმპლემენტაცია ზედმიწევნით მიყვება დავალების პირობაში მოცემულ ფორმულებს. `recalculate_load_avg`-ისა და `recalculate_recent_cpu`-ს გამოძახება ხდება ყოველ წამში ერთხელ, ხოლო `recalculate_priority` ითვლება ყოველ 4 *tick*-ში ერთხელ.

## სინქრონიზაცია

ნაკადებს შორის კონკურენცია სრულად მოგვარებულია წინა ნაწილის, პრიორიტეტების მიხედვით დამგეგმავის მეშვეობით. ერთადერთი რისი სინქრონიზაციის პრობლემაც შეიძლება გაჩენილიყო, არის *interrupt*-ები. ამიტომაც თითოეული ნაკადის პრიორიტეტის ყოველი გადათვლის განმავლობაში ისინი გამორთულია.

# დამატებითი კითხვები

## 1

## 2

timer ticks | R(A) | R(B) | R(C) | P(A) | P(B) | P(C) | thread to run
------------|------|------|------|------|------|------|--------------
 0          | 0    | 0    | 0    | 63   | 61   | 59   | a
 4          | 4    | 0    | 0    | 62   | 61   | 59   | a
 8          | 8    | 0    | 0    | 61   | 61   | 59   | b
12          | 8    | 4    | 0    | 61   | 60   | 59   | a
16          | 12   | 4    | 0    | 60   | 60   | 59   | b
20          | 12   | 8    | 0    | 60   | 59   | 59   | a
24          | 16   | 8    | 0    | 59   | 59   | 59   | c
28          | 16   | 8    | 4    | 59   | 59   | 58   | b
32          | 16   | 12   | 4    | 59   | 58   | 58   | a
36          | 20   | 12   | 4    | 58   | 58   | 58   | c

## 3

ზოგიერთ დროს რამდენიმე გაშვებადი ნაკადის პრიორიტეტები იყო ზუსტად ერთნაირი; ამ შემთხვევაშიც გამოვიყენე ჩვენ მიერ მოფიქრებული რიგის სტრუქტურა და თუ პრიორიტეტი ეცვლებოდა ნაკადს, მაშინ ამოვარდებოდა რიგიდან და ვარდებოდა თავისნაირი პრიორიტეტების მქონეების თავში, ხოლო ამოღება ხდებოდა ბოლოდან, რაც იწვევს იმას, რომ ერთნაირი პრიორიტეტების შემთხვევაში ნაკადები იქცევიან *round robin*-ის მიხედვით.
