პროექტი #2 - იუზერის პროგრამები: დიზაინ დოკუმენტი
========================================

#### თბილისის თავისუფალი უნივერსიტეტი,  MACS, ოპერაციული სისტემების ინჟინერია, გაზაფხული-2018.

### ჯგუფის წევრები

* <a href="ggvel14@freeuni.edu.ge">გიორგი გველესიანი</a>
* <a href="aabra12@freeuni.edu.ge">ალექსანდრე აბრამიშვილი</a>
* <a href="alkakh14@freeuni.edu.ge">ალექსანდრე კახიძე</a>
* <a href="anaka13@freeuni.edu.ge">ალექსანდრე ნაკაიძე</a>

# 1. Argument Passing
*არგუმენტების გადაცემა*

## მონაცემთა სტრუქტურები და ფუნქციები

### ფუნქციები

* `static uint16_t get_first_token_len(const char *str)` - აბრუნებს გადაცემული სტრინგის პირველი სიტყვის სიგრძეს, ანუ პირველივე ჰარამდე სიმბოლოების რაოდენობას. ვიყენებთ `char`-ების მასივის შესაქმნელად, შემდეგი ფუნქციისთვის.
* `static char *get_first_token(char *dest, const char *src, uint16_t len)` - აბრუნებს და `dest`-ში წერს `src` სტრინგის პირველ `len` რაოდენობის სიმბოლოს. ვიყენებთ სტრინგის პირველი ტოკენის ამოსაღებად, ანუ ამ შემთხვევაში არგუმენტების სიიდან ფაილის სახელის გასაგებად.

## ალგორითმები

ამ ფუნქციონალის იმპლემენტაცია საკმაოდ სწორხაზოვნად იმეორებს დავალების პირობაში მოცემულ მითითებებს:

* ვიღებთ ფაილის სახელისა და არგუმენტებისგან შემდგარ„
 სტრინგ `file_name`-ს, რომელიც `process_execute()` ფუნქციას გადმოეცემა და ვყოფთ ჰარების მიხედვით.
* თითოეულ მიღებულ ელემენტს შებრუნებული თანმიმდევრობით ვწერთ მეხსიერებაში `PHYS_BASE`-იდან დაწყებული კლებადი მიმართულებით.
* შემდეგ ვწერთ საჭიროებისამებრ რამდენიმე 0-ს გასაოთხისჯერადებლად და კიდევ სტანდარტის მიხედვით *null pointer*-ს.
* მერე ვწერთ მეორე ეტაპზე ჩაწერილი თითოეული არგუმენტის მისამართს.
* ბოლოს კი - ამ მისამართებზე მისამართს, არგუმენტების რაოდენობასა და ფსევდო `return address`-ს.

ეს სია მართლა ზედმიწევნით შევასრულეთ, თუ არ ჩავთვლით, კოდის რამდენიმე პატარა ოპტიმიზაციას, მაგალითად იმ ადგილას, სადაც *null pointer*-ი უნდა ჩაგვესვა, იმის გამო, რომ ჩასაწერ მისამართებს `PHYS_BASE`-ზე ვნაშთავდით, არგუმენტების მისამართების ჩაწერის დროს ეს *null pointer*-იც თავის შესაბამის ადგილას ავტომატურად ჩაიწერა. და დავალებაც შესრულდა.

## სინქრონიზაცია

ამ ფუნქციონალს სინქრონიზაცია არ სჭირდება, რადგან ერთი ფუნქციის შიგნით ხდება და ყოველი პროცესისთვის მისი *stack*-ის შევსება ინდივიდუალურია.

## რატომ ავირჩიეთ ეს მიდგომა

დიდად მიდგომის არჩევის საშუალებაც არ მოგვეცა, იმდენად პირდაპირ გავიმეორეთ დავალების პირობაში მოცემული ინსტრუქცია.

# 2. Process Control Syscalls
*პროცესის კონტროლის სისტემური ბრძანებები*

## მონაცემთა სტრუქტურები და ფუნქციები

### სტრუქტურები

* `struct child_info` - ინახავს *exit status*-სა და მისთვის საჭირო სინქრონიზაციის მეთოდებს თითოეული ნაკადისთვის. არსებობს მაშინაც კი, როდესაც ეს ნაკადი მკვდარია.
* `struct file_with_sema` - ინახავს *executable* ფაილის სახელსა და `exec` სისტემური ბრძანებისთვის დასაბრუნებელი მნიშვნელობის სტატუსს.

### ცვლადები

ცვლადები `struct child_info`-ში:

* `tid_t tid` - ნაკადის *id*.
* `int status` - პროცესის *exit status*-ი.
* `bool is_alive` - თუკი ეს ნაკადიც და მშობელიც ორივე ცოცხალია, მაშინ ამ ცვლადის მნიშვნელობა არის `true`, ხოლო ერთი მათგანი მაინც თუ მკვდარია, მაშინ `false`. ვიყენებთ იმის გასარკვევად უსაფრთხო არის თუ არა ამ სტრუქტურის მეხსიერებიდან წაშლა.
* `struct semaphore sema_wait_for_child` - სემაფორა, რომლის გათავისუფლებასაც ელოდება მშობელი *wait*-ის დროს.
* `struct lock *parent_free_lock` - მიმთითებელი მშობელი ნაკადის `free_lock`-ზე.
* `struct list_elem elem` - ელემენტი იმ სიისა, რომელიც აქვს ამ ნაკადის მშობელს.

დამატებითი ცვლადები `struct thread`-ში:

* `struct list child_infos` - შვილი ნაკადების *exit status*-ების *info*-ების სია.
* `struct child_info *info` - საკუთარი *exit status*-ის *info*-ზე მიმთითებელი.
* `struct lock free_lock` - *lock*-ი, რომელიც გამოიყენება შვილების *info*-ების სიაზე მანიპულაციის დროს სინქრონიზაციისთვის.
* `int exit_status` - ამ ნაკადის *exit status*-ი.
* `struct file *executable` - ამ ნაკადის მიერ გაშვებად ფაილზე მიმთითებელი.

ცვლადები `struct file_with_sema`-ში:

* `char *file` - გაშვებადი ფაილის სახელი.
* `struct semaphore *sema` - სემაფორა, რომელიც გამოიყენება `exec` სისტემური ბრძანების დასრულების დალოდებისთვის.
* `bool *status` - `true`-ა იმ შემთხვევაში, თუ ფაილის გაშვება მოხერხდა, ხოლო `false` - საწინააღმდეგო შემთხვევაში.

### ფუნქციები

დამატებითი ფუნქციები `process.c`-ში:

* `struct child_info *get_child_info (struct thread *parent, tid_t child_tid)` - აბრუნებს `parent` ნაკადის `child_tid`-ის მქონე *id*-ით შვილის *exit status*-ის *info*-ს, თუკე ასეთი მოიძებნა.

დამატებითი ფუნქციები `syscall.c`-ში:

* `int practice(int i)` - სისტემური ბრძანება `practice`-ის შემსრულებელი ფუნქცია.
* `static void halt(void)` - სისტემური ბრძანება `halt`-ის შემსრულებელი ფუნქცია.
* `void exit(int status)` - სისტემური ბრძანება `exit`-ის შემსრულებელი ფუნქცია.
* `static pid_t exec(const char *file)` - სისტემური ბრძანება `exec`-ის შემსრულებელი ფუნქცია.
* `static int wait(pid_t pid)` - სისტემური ბრძანება `wait`-ის შემსრულებელი ფუნქცია.
* `static bool is_valid_address(void *p)` - ამოწმებს გადმოცემული მისამართის ვალიდურობას და იმას, გამომძახებელი იუზერის მეხსიერებაში არის თუ არა.
* `static uint32_t *get_arg_int(uint32_t *p)` - ამოწმებს გადმოცემული მიმთითებლის ოთხივე ბაიტის ვალიდურობას.
* `static void *get_arg_pointer(void *p, int len)` - ამოწმებს `p` მისამართზე არსებული მეხსიერების ვალიდურობას, `len`-ის არსებობის შემთხვევაში `len` ბაიტს, თუარადა *null terminator*-ამდე.

## ალგორითმები

სანამ თითოეული სისტემური ბრძანების შესაბამისი ფუნქცია გამოიძახება, `syscall_handler`-იდან ხდება *stack*-ში ჩალაგებული არგუმენტების ამოღება და მათი მეხსიერებების ვალიდურობის შემოწმება.

### Practice

უმატებს გადმოცემულ მთელ რიცხვს ერთს.

### Halt

თიშავს სისტემას.

### Exec

იძახებს `process_execute` ფუნქციას, რომელიც თავის მხრივ ქმნის ახალ ნაკადს, რომელსაც გასაშვებ ფუნქციად აქვს გადაცემული `start_process`-ი, რომელიც უშვებს `exec`-ისთვის გადმოცემული ფაილის სახელის შესაბამის ფაილს.
სწორედ `process_execute`-ის დროს ხდება სემაფორა `sema`-ს ინიციალიზაცია და შემდეგ დალოდება, როდის განთავისუფლდება. ხოლო გაანთავისუფლეს მას შვილი ნაკადის `start_process` ფუნქცია მას შემდეგ რაც გაირკვევა გაეშვა თუ არა პროგრამა.

### Wait

იძახებს `process_wait`-ს, რომელშიც ხდება გადმოცემული *id*-ის მქონე შვილი პროცესის მოძებნა, რომ მას დაელოდოს მშობელი. ელოდება სემაფორა `sema_wait_for_child`-ის მეშვეობით, რომელიც თავისუფლდება მხოლოდ შვილი პროცესის `exit`-ის დროს. აბრუნებს შვილის *exit status*-სა და შლის შვილის `child_info`-ს.

### Exit

იძახებს `process_exit`-ს, რომელშიც გარდა ამ ნაკადისთვის გამოყოფილი მეხსიერების განთავისუფლებისა ხდება დახოცილი შვილების შესაბამისი `struct child_info`-ების წაშლა და ცოცხლებისთვის შეტყობინება, რომ მშობელი გარდაეცვალათ. ასევე თუკი ამ ნაკადის მშობელი მკვდარია, თავისივე *info*-ც იშლება, ხოლო თუ ცოცხალია, ატყობინებს მას, რომ შვილი მოუკვდა. ბოლოს კი იხურება *executable* ფაილი.

## სინქრონიზაცია

ამ დავალებაში სინქრონიზაცია საკმაოდ რთული პროცედურაა. გარდა იმისა, რომ `exec`-ისას შვილის გაშვებასა და `wait`-ისას შვილის `exit`-ს ელოდება მშობელი სწორედ სინქრონიზაციის მეთოდებით, ამ შემთხვევაში `struct semaphore *sema`-თი და `struct semaphore sema_wait_for_child`-ით, იმ დროს, როდესაც ხდება მშობლისა და შვილის კომუნიკაცია, ყოველთვის საჭიროა სინქრონიზაცია, ამიტომ ამ დროს ვიყენებთ მშობელი პროცესის ნაკადის სტრუქტურაში ჩადებულ `free_lock`-ს, რომელზე მიმთითებელიც უნაწილდება ყველა შვილს.

## რატომ ავირჩიეთ ეს მიდგომა

ჩვენი არჩეული მიდგომებით მშობელი და შვილი პროცესები დამოუკიდებლად ახერხებენ მუშაობის გაგრძელებას და რაც მთავარია ბევრ რესურსს არ იყენებენ. მეხსიერებაში ზედმეტი რამდენიმე ათეული ბაიტი იწერება, ხოლო დრო არცერთ ჩვენს მიერ განხორციელებულ სისტემურ ბრძანებას ბევრი არ მიაქვს. ერთადერთი რაც ზომაზე დამოკიდებულია, არის `struct list child_infos`, ანუ შვილების *exit status* ების შემნახველი სტრუქტურების სია, რომელშიც ძებნა ხდება O(n)-ში, თუმცა არც ეს მაჩვენებელი არ ქმნის სისტემისთვის ოდნავ მაინც სახიფათო მდგომარეობას თუმდაც ათასობით შვილი პროცესის შემთხვევაში, რადგან ეს O(n) გადაყოლა ხდება მხოლოდ `wait`-ისა და `exit`-ის დროს, როდესაც მშობელი ან ისედაც ელოდება შვილებს, ან სულაც კვდება და მეტი შესასრულებელი საქმე არ აქვს.

# 3. File Operation Syscalls
*ფაილებზე მოქმედებების სისტემური ბრძანებები*

## მონაცემთა სტრუქტურები და ფუნქციები

### ცვლადები

* `struct lock filesys_lock` - *lock*-ი, რომელიც გამოიყენება ფაილური სისტემის ჩასაკეტად მაშინ, როცა მასზე რამე მანიპულაცია ხდება.
* `#define FD_MAX 128` - ერთი პროცესისთვის მაქსიმალური გახსნილი ფაილების რაოდენობა.

დამატებითი ცვლადები `struct thread`-ში:

* `struct file *descls[FD_MAX]` - მასივი, რომელშიც შენახულია ამ ნაკადის ფაილდესკრიპტორები, ანუ გახსნილი ფაილების იდენტიფიკატორები.

### ფუნქციები

* `bool create(const char *file, unsigned initial_size)` - სისტემური ბრძანება `create`-ის შემსრულებელი ფუნქცია.
* `bool remove(const char *file)` - სისტემური ბრძანება `remove`-ის შემსრულებელი ფუნქცია.
* `int open(const char *file)` - სისტემური ბრძანება `open`-ის შემსრულებელი ფუნქცია.
* `int filesize(int fd)` - სისტემური ბრძანება `filesize`-ის შემსრულებელი ფუნქცია.
* `int read(int fd, void *buffer, unsigned size)` - სისტემური ბრძანება `read`-ის შემსრულებელი ფუნქცია.
* `int write(int fd, const void *buffer, unsigned size)` - სისტემური ბრძანება `write`-ის შემსრულებელი ფუნქცია.
* `void seek(int fd, unsigned position)` - სისტემური ბრძანება `seek`-ის შემსრულებელი ფუნქცია.
* `unsigned tell(int fd)` - სისტემური ბრძანება `tell`-ის შემსრულებელი ფუნქცია.
* `void close(int fd)` - სისტემური ბრძანება `close`-ის შემსრულებელი ფუნქცია.

## ალგორითმები

ზოგადი აღწერა:
ფაილდესკრიპტორების შენახვის მეთოდი

### Create



### Remove



### Open



### Close



### Filesize



### Read



### Write



### Seek



### Tell



## სინქრონიზაცია

გლობალური ლოქი

## რატომ ავირჩიეთ ეს მიდგომა



# დამატებითი კითხვები

## 1



## 2



## 3

