პროექტი #2 - იუზერის პროგრამები: დიზაინ დოკუმენტი
========================================

#### თბილისის თავისუფალი უნივერსიტეტი,  MACS, ოპერაციული სისტემების ინჟინერია, გაზაფხული-2018.

### ჯგუფის წევრები

* <a href="ggvel14@freeuni.edu.ge">გიორგი გველესიანი</a>
* <a href="aabra12@freeuni.edu.ge">ალექსანდრე აბრამიშვილი</a>
* <a href="alkakh14@freeuni.edu.ge">ალექსანდრე კახიძე</a>
* <a href="anaka13@freeuni.edu.ge">ალექსანდრე ნაკაიძე</a>

# 1. Argument Passing
*არგუმენტების გადაცემა*

## მონაცემთა სტრუქტურები და ფუნქციები

### ფუნქციები

* `static uint16_t get_first_token_len(const char *str)` - აბრუნებს გადაცემული სტრინგის პირველი სიტყვისსიგრძეს, ანუ პირველივე ჰარამდე სიმბოლოების რაოდენობას. ვიყენებთ `char`-ების მასივის შესაქმნელად, შემდეგი ფუნქციისთვის.
* `static char *get_first_token(char *dest, const char *src, uint16_t len)` - აბრუნებს და `dest`-ში წერს `src` სტრინგის პირველ `len` რაოდენობის სიმბოლოს. ვიყენებთ სტრინგის პირველი ტოკენის ამოსაღებად, ანუ ამ შემთხვევაში არგუმენტების სიიდან ფაილის სახელის გასაგებად.

## ალგორითმები

ამ ფუნქციონალის იმპლემენტაცია საკმაოდ სწორხაზოვნად იმეორებს დავალების პირობაში მოცემულ მითითებებს:

* ვიღებთ ფაილის სახელისა და არგუმენტებისგან შემდგარ„
 სტრინგ `file_name`-ს, რომელიც `process_execute()` ფუნქციას გადმოეცემა და ვყოფთ ჰარების მიხედვით.
* თითოეულ მიღებულ ელემენტს შებრუნებული თანმიმდევრობით ვწერთ მეხსიერებაში `PHYS_BASE`-იდან დაწყებული კლებადი მიმართულებით.
* შემდეგ ვწერთ საჭიროებისამებრ რამდენიმე 0-ს გასაოთხისჯერადებლად და კიდევ სტანდარტის მიხედვით *null pointer*-ს.
* მერე ვწერთ მეორე ეტაპზე ჩაწერილი თითოეული არგუმენტის მისამართს.
* ბოლოს კი - ამ მისამართებზე მისამართს, არგუმენტების რაოდენობასა და ფსევდო `return address`-ს.

ეს სია მართლა ზედმიწევნით შევასრულეთ, თუ არ ჩავთვლით, კოდის რამდენიმე პატარა ოპტიმიზაციას, მაგალითად იმ ადგილას, სადაც *null pointer*-ი უნდა ჩაგვესვა, იმის გამო, რომ ჩასაწერ მისამართებს `PHYS_BASE`-ზე ვნაშთავდით, არგუმენტების მისამართების ჩაწერის დროს ეს *null pointer*-იც თავის შესაბამის ადგილას ავტომატურად ჩაიწერა. და დავალებაც შესრულდა.

## სინქრონიზაცია

ამ ფუნქციონალს სინქრონიზაცია არ სჭირდება, რადგან ერთი ფუნქციის შიგნით ხდება და ყოველი პროცესისთვის მისი *stack*-ის შევსება ინდივიდუალურია.

## რატომ ავირჩიეთ ეს მიდგომა

დიდად მიდგომის არჩევის საშუალებაც არ მოგვეცა, იმდენად პირდაპირ გავიმეორეთ დავალების პირობაში მოცემული ინსტრუქცია.

# 2. Process Control Syscalls
*პროცესის კონტროლის სისტემური ბრძანებები*

## მონაცემთა სტრუქტურები და ფუნქციები

### ცვლადები

დამატებითი ცვლადები `struct thread`-ში:

* 

დამატებითი ცვლადი `struct semaphore_elem`-ში:

* 

### ფუნქციები

* 

## ალგორითმები

### Practice



### Halt



### Exec



### Wait



### Exit



## სინქრონიზაცია

თითოეული ლოქი/სემაფორა
დროი/მეხსიერების გამოყენება

## რატომ ავირჩიეთ ეს მიდგომა



# 3. File Operation Syscalls
*ფაილებზე მოქმედებების სისტემური ბრძანებები*

## მონაცემთა სტრუქტურები და ფუნქციები

### ცვლადები

* 

დამატებითი ცვლადები `struct thread`-ში:

* 

### ფუნქციები

* 

## ალგორითმები

ზოგადი აღწერა:
ფაილდესკრიპტორების შენახვის მეთოდი
მისამართის ვალიდურობის შემოწმება

### Create



### Remove



### Open



### Close



### Filesize



### Read



### Write



### Seek



### Tell



## სინქრონიზაცია

გლობალური ლოქი

## რატომ ავირჩიეთ ეს მიდგომა



# დამატებითი კითხვები

## 1



## 2



## 3

